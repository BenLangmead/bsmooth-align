#!/usr/bin/env perl

#
# Copyright 2012, Ben Langmead <blangmea@jhsph.edu>
#
# This file is part of The BSmooth Alignment Pipeline.
#
# The BSmooth Alignment Pipeline is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# The BSmooth Alignment Pipeline is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# The BSmooth Alignment Pipeline.  If not, see <http://www.gnu.org/licenses/>.
#

##
# bswc_sam_extract.pl
#
# Extract evidence from pairs of BSWC-SAM file.  A BSWC-SAM file is output by
# a tool like Bowtie that can't align in a fully bisulfite-aware fashion
# without the help of wrapper scripts such as the bswc_* scripts included here.
# Tools that are bisilfute aware, such as Merman, output a different type of
# SAM file called BS-SAM here.
#

use strict;
use warnings;
use Getopt::Long;
use File::Path;
use File::Basename;
use FindBin qw($Bin);
use lib "$Bin/../lib";
use BtlBio::Alignment::Alignment;
use BtlBio::Alignment::SAM;
use BtlBio::Align::Bisulfite::BsAlign;
use BtlBio::Align::Bisulfite::BsEvidence;
use BtlBio::Util::File;
use BtlBio::Util::Tool;
use BtlBio::Util::Temp;
use BtlBio::Format::SamBam::SamBam;
use BtlBio::Format::Fasta;
use POSIX;
use Carp;

my $samtools_exe = "samtools";  # path to samtools bin; only for --keep-bam
my $temp_dir = $ENV{TMPDIR};    # temp dir for intermediates; reads, alns
my %ref = ();                   # all the reference sequences
my $bscpg = 1;                  # 1 -> do CpG->YpG conversion
my $bsc = 0;                    # 1 -> do C->Y conversion
my $echo_sam = 0;               # print out SAM as it comes in
my $strand4 = 0;                # using 4-strand protocol?
my $ev_out_dir = ".";           # directory to write evidence

my @ref_fns = ();       # fasta files with references

my $usage = qq!

Given .watson.sam and .crick.sam files output by a bswc_*.pl wrapper script,
extract and output methylation evidence.

Usage:
  bswc_sam_extract.pl [options*] -- <refs> -- <watson-sam/bam> -- <crick-sam/bam>

  <refs>
    Fasta files containing all original reference sequences
  <watson-sam/bam>
    A list of .sam and/or .bam files containing alignments generated by a
    bswc_*.pl script (NOT bs_*.pl script - use bs_sam_extract.pl for that).
  <crick-sam/bam>
    A list of .sam and/or .bam files containing alignments generated by a
    bswc_*.pl script (NOT bs_*.pl script - use bs_sam_extract.pl for that).

Options (defaults in parentheses):
  --echo-sam             Print SAM alignments to STDOUT as they're read in
  --four-strand          Align to BSW/BSWR/BSC/BSCR strands (def: just BSW/BSC)
  --bscpg                CpG Cs become Ys, other Cs become Ts; extract evidence
                         from CpG Cs (on)
   OR:
  --bsc                  All Cs become Ys; extract evidence from all Cs (off)
   *** --bsc/--bscpg and --four-strand must be set to match the exact    ***
   *** settings used when creating the alignments                        ***
!;

##
# Print and run given command.  Die if it returns non-zero.
#
sub run($) {
	my $cmd = shift;
	print STDERR "Running '$cmd'...\n";
	system($cmd);
	$? == 0 || croak("Command '$cmd' failed with exitlevel $?\n");
}

##
# Die and print the usage message.
#
sub dieusage($$) {
	my ($msg, $level) = @_;
	print STDERR "$usage\n--\n";
	print STDERR "Error $level:\n";
	print STDERR "$msg\n";
	exit $level;
}

GetOptions (
	"samtools=s"      => \$samtools_exe,
	"temp=s"          => \$temp_dir,
	"bscpg"           => sub { $bscpg = 1; $bsc = 0; },
	"bsc"             => sub { $bscpg = 0; $bsc = 1; },
	"four-strand"     => \$strand4,
	"echo-sam"        => \$echo_sam,
	"output-dir=s"    => \$ev_out_dir
) || dieusage("Bad option", 0);

mkpath($ev_out_dir);

# Parse out arguments from among the double-dashes
my $dds = 0;
my @sam_fns_wat = ();
my @sam_fns_cri = ();
for my $a (@ARGV) {
	if($a eq "--") {
		$dds++; next;
	}
	if($dds == 0) {
		push @ref_fns, $a;
	} elsif($dds == 1) {
		push @sam_fns_wat, $a;
	} else {
		push @sam_fns_cri, $a;
	}
}

scalar(@sam_fns_wat) == scalar(@sam_fns_cri) ||
	die "Must specify same number of watson and crick input files. ".
	    "Got ".scalar(@sam_fns_wat)." watson, ".scalar(@sam_fns_cri)." crick.";

print STDERR "Reference files:\n";
for(0..$#ref_fns) {print STDERR "  $ref_fns[$_]\n"}
print STDERR "Conversion type: ".($bscpg ? "BSCPG" : "BSC")."\n";
print STDERR "Four-strand?: ".($strand4 ? "yes":"no")."\n";

print STDERR "Parsing reference...\n";
for(@ref_fns) { read_fasta_to_hash($_, \%ref, { truncate_names => 1 }); }
print STDERR "  Parsed ".scalar(keys %ref)." sequences\n";

# Now we have filehandles from which to read the two streams of alignments,
# one with alignments to BSW/BSWR, one with alignments to BSC/BSCR
my $nskip_wat_cri = 0;
my $nheads = 0;
my $nrecs = 0;
my $nrec_ival = 1000;
my %ev_out_fhs = ();
##
# Given a piece of methylation evidence, simply print it to STDOUT.
#
my $nev = 0;
open(MARK, ">$ev_out_dir/.".($bscpg ? "cpg" : "c").".ev") || die;
print MARK "\n"; close(MARK);
sub evidenceSink($) {
	my $ev = shift;
	$nev++;
	my $tname = $ev->{_tname};
	$tname =~ s/\s.*//;
	$tname = sanitize_filename($tname);
	my $outfn = "$ev_out_dir/$tname.ev.tsv";
	if(!defined($ev_out_fhs{$outfn})) {
		open($ev_out_fhs{$outfn}, ">$outfn") ||
			die "Could not open '$outfn' for writing";
		my $outbinfn = "$ev_out_dir/.$tname.ev.tsv.bin";
		open(TMP, ">$outbinfn") ||
			die "Could not open '$outbinfn' for writing";
		print TMP "$ev->{_tname}\n"; # original, not sanitized
		close(TMP);
	}
	print {$ev_out_fhs{$outfn}} $ev->to_record."\n";
}
print STDERR "Processing SAM output from aligners...\n";
if(0) {
	my ($last_al_wat, $last_al_cri);
	for my $i (0..$#sam_fns_wat) {
		my ($fn_wat, $fn_cri) = ($sam_fns_wat[$i], $sam_fns_cri[$i]);
		my ($al_fh_wat, $format_wat) = sam_input_stream($fn_wat, $samtools_exe);
		my ($al_fh_cri, $format_cri) = sam_input_stream($fn_cri, $samtools_exe);
		while(1) {
			# Output is in SAM format
			my $line_wat = readline $al_fh_wat;
			my $line_cri = readline $al_fh_cri;
			defined($line_wat) == defined($line_cri) ||
				die "SAM inputs ended at different lines";
			last unless defined($line_wat);
			print $line_wat if $echo_sam;
			print $line_cri if $echo_sam;
			my $firstc_wat = substr($line_wat, 0, 1);
			my $firstc_cri = substr($line_cri, 0, 1);
			if($firstc_wat eq "\@") {
				# Header line
				$nheads++;
				$firstc_cri eq "\@" || die;
				next; # skip
			}
			# Create Alignment objects for both
			my $al_wat = parse_sam_record($line_wat);
			my $al_cri = parse_sam_record($line_cri);
			$al_wat->{_rdname} eq $al_cri->{_rdname} || die;
			if($strand4) {
				if(defined($last_al_wat)) {
					my $nm1 = $al_wat->{_rdname};      $nm1 =~ s/:.*$//;
					my $nm2 = $last_al_wat->{_rdname}; $nm2 =~ s/:.*$//;
					$nm1 eq $nm2 || die "+/- names must match!\n$nm1\n$nm2";
					my $sel_al = undef;
					my $nal = 0;
					my $watson = undef;
					for my $al ($al_wat, $last_al_wat) {
						if($al->aligned) { $nal++; $sel_al = $al; $watson = 1; }
					}
					for my $al ($al_cri, $last_al_cri) {
						if($al->aligned) { $nal++; $sel_al = $al; $watson = 0; }
					}
					$nal > 0 || die;
					defined($watson) || die;
					if($nal == 1) {
						if($bsc) {
							bsc_analyze_alignment($sel_al, $watson, \%ref, \&evidenceSink, undef, undef);
						} else {
							bscpg_analyze_alignment($sel_al, $watson, \%ref, \&evidenceSink, undef, undef);
						}
					} else {
						$nskip_wat_cri++;
					}
					($last_al_wat, $last_al_cri) = (undef, undef);
				} else {
					($last_al_wat, $last_al_cri) = ($al_wat, $al_cri);
				}
			} else {
				# Are there alignments on both strands?
				if($al_wat->aligned && $al_cri->aligned) {
					$nskip_wat_cri++; # Yes!  Ignore
				} elsif($al_wat->aligned) {
					if($bsc) { bsc_analyze_alignment($al_wat, 1, \%ref, \&evidenceSink, undef, undef); }
					else     { bscpg_analyze_alignment($al_wat, 1, \%ref, \&evidenceSink, undef, undef); }
				} elsif($al_cri->aligned) {
					if($bsc) { bsc_analyze_alignment($al_cri, 0, \%ref, \&evidenceSink, undef, undef); }
					else     { bscpg_analyze_alignment($al_cri, 0, \%ref, \&evidenceSink, undef, undef); }
				}
			}
			if((++$nrecs % $nrec_ival) == 0) {
				print STDERR "  Processed $nrecs BSWC-SAM record pairs...\n";
			}
		}
		close($al_fh_wat);
		close($al_fh_cri);
	}
} else {
	for (my $i = 0; $i < scalar(@sam_fns_wat) + scalar(@sam_fns_cri); $i++) {
		my $ii = $i;
		my $fn = undef;
		my $watson = 0;
		if($ii >= scalar(@sam_fns_wat)) {
			$ii -= scalar(@sam_fns_wat);
			$fn = $sam_fns_cri[$ii];
		} else {
			$watson = 1;
			$fn = $sam_fns_wat[$ii];
		}
		my ($al_fh, $format) = sam_input_stream($fn, $samtools_exe);
		while(1) {
			# Output is in SAM format
			my $line = readline $al_fh;
			defined($line) == defined($line) || die "SAM inputs ended at different lines";
			last unless defined($line);
			print $line if $echo_sam;
			my $firstc = substr($line, 0, 1);
			if($firstc eq "\@") {
				# Header line
				$nheads++;
				next; # skip
			}
			# Create Alignment objects for both
			my $al = parse_sam_record($line);
			bsc_analyze_alignment  ($al, $watson, \%ref, \&evidenceSink, undef, undef) if  $bsc;
			bscpg_analyze_alignment($al, $watson, \%ref, \&evidenceSink, undef, undef) if !$bsc;
			if((++$nrecs % $nrec_ival) == 0) {
				print STDERR "  Processed $nrecs BSWC-SAM record pairs...\n";
			}
		}
		close($al_fh);
	}
}
print STDERR "Summary:\n";
print STDERR "  SAM header lines parsed: $nheads\n";
print STDERR "  SAM record pairs parsed: $nrecs\n";
print STDERR "  Pieces of evidence extracted: $nev\n";

for my $ofh (%ev_out_fhs) { close($ofh); }
